/*
 * This is part of the FL library, a C++ Bayesian filtering library
 * (https://github.com/filtering-library)
 *
 * Copyright (c) 2014 Jan Issac (jan.issac@gmail.com)
 * Copyright (c) 2014 Manuel Wuthrich (manuel.wuthrich@gmail.com)
 *
 * Max-Planck Institute for Intelligent Systems, AMD Lab
 * University of Southern California, CLMC Lab
 *
 * This Source Code Form is subject to the terms of the MIT License (MIT).
 * A copy of the license can be found in the LICENSE file distributed with this
 * source code.
 */

/**
 * \file monte_carlo_transform.hpp
 * \date October 2014
 * \author Jan Issac (jan.issac@gmail.com)
 */

#ifndef FL__FILTER__GAUSSIAN__MONTE_CARLO_TRANSFORM_HPP
#define FL__FILTER__GAUSSIAN__MONTE_CARLO_TRANSFORM_HPP

#include <fl/util/traits.hpp>
#include <fl/distribution/gaussian.hpp>
#include <fl/filter/gaussian/point_set_transform.hpp>

namespace fl
{

template <size_t NumberOfPoints>
struct ConstantNumberOfPointsPolicy
{
    static constexpr size_t number_of_points(int dimension)
    {
        return NumberOfPoints;
    }
};

template <size_t Factor = 1, size_t Min = 0>
struct LinearNumberOfPointsPolicy
{
    static constexpr size_t number_of_points(int dimension)
    {
        return (dimension != Eigen::Dynamic)
                    ? Factor * dimension + Min
                    : Eigen::Dynamic;
    }
};

template <size_t Factor = 1, size_t Min = 0>
struct QuadraticNumberOfPointsPolicy
{
    static constexpr size_t number_of_points(int dimension)
    {
        return (dimension != Eigen::Dynamic)
                    ? Factor * dimension * dimension + Min
                    : Eigen::Dynamic;
    }
};


/**
 * \ingroup sigma_point_kalman_filters
 * \ingroup point_set_transform
 *
 * This is the Unscented Transform used in the Unscented Kalman Filter
 * \cite wan2000unscented . It implememnts the PointSetTransform interface.
 *
 * \copydetails PointSetTransform
 */
template <
    typename NumberOfPointsPolicy = LinearNumberOfPointsPolicy<>
>
class MonteCarloTransform
        : public PointSetTransform<MonteCarloTransform<NumberOfPointsPolicy>>
{
public:
    /**
     * Creates a MonteCarloTransform
     *
     * \param eta       Factor determining the number of point by
     *                  \f$\eta dim(X)\f$ where \f$X\f$ is the Gaussian variate
     */
    MonteCarloTransform()
        : PointSetTransform<MonteCarloTransform<NumberOfPointsPolicy>>(this)
    { }


    /**
     * \copydoc PointSetTransform::forward(const Gaussian&,
     *                                     PointSet&) const
     *
     * \throws WrongSizeException
     * \throws ResizingFixedSizeEntityException
     */
    template <typename Gaussian_, typename PointSet_>
    void forward(const Gaussian_& gaussian,
                 PointSet_& point_set) const
    {
        forward(gaussian, gaussian.dimension(), 0, point_set);
    }

    /**
     * \copydoc PointSetTransform::forward(const Gaussian&,
     *                                     size_t global_dimension,
     *                                     size_t dimension_offset,
     *                                     PointSet&) const
     *
     * \throws WrongSizeException
     * \throws ResizingFixedSizeEntityException
     */
    template <typename Gaussian_, typename PointSet_>
    void forward(const Gaussian_& gaussian,
                 size_t global_dimension,
                 size_t dimension_offset,
                 PointSet_& point_set) const
    {
        const size_t point_count = number_of_points(global_dimension);
        const double w = 1./double(point_count);

        for (int i = 0; i < point_count; ++i)
        {
            point_set.point(i, gaussian.sample(), w);
        }
    }

    /**
     * \return Number of points generated by this transform
     *
     * \param dimension Dimension of the Gaussian
     */
    static constexpr size_t number_of_points(int dimension)
    {
        return NumberOfPointsPolicy::number_of_points(dimension);
    }
};

}

#endif
