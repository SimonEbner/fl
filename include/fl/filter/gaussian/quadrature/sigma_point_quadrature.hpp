/*
 * This is part of the FL library, a C++ Bayesian filtering library
 * (https://github.com/filtering-library)
 *
 * Copyright (c) 2014 Jan Issac (jan.issac@gmail.com)
 * Copyright (c) 2014 Manuel Wuthrich (manuel.wuthrich@gmail.com)
 *
 * This Source Code Form is subject to the terms of the MIT License (MIT).
 * A copy of the license can be found in the LICENSE file distributed with this
 * source code.
 */

/**
 * \file sigma_point_quadrature.hpp
 * \date July 2015
 * \author Jan Issac (jan.issac@gmail.com)
 */

#ifndef FL__FILTER__GAUSSIAN__SIGMA_POINT_QUADRATURE_HPP
#define FL__FILTER__GAUSSIAN__SIGMA_POINT_QUADRATURE_HPP

#include <fl/util/meta.hpp>
#include <fl/util/traits.hpp>
#include <fl/util/descriptor.hpp>
#include <fl/distribution/gaussian.hpp>
#include <fl/filter/gaussian/transform/point_set.hpp>

namespace fl
{

// Forward declaration
template <typename ... > class SigmaPointQuadrature;

/**
 * \ingroup numeric_integration
 *
 * \brief Represents a numeric integration tool based on sigma point selections
 *        of Gaussian distribution
 *
 * ## Examples: Expectation computation ##
 *
 * ### Computing the first moment (mean) ####
 * \f$\mathbb{E}[f(x)] = \displaystyle\int f(x) p(x) \mathrm{d}x\f$
 *
 * \code
 * typedef Eigen::Vector<Real, 10> MyVariate;
 *
 * MyVariate some_function(const MyVariate& x) { return ...; }
 *
 * ...
 *
 * // setup a gaussian distribution
 * Gaussian<MyVariate> p;
 * p.mean(MyVariate::Random(10));
 * p.covariance(p.covariance() * std::rand());
 *
 * // create the lambda we will pass to the integrator
 * auto f = [&](const MyVariate& x) -> MyVariate { return some_function(x); };
 *
 * auto f_mean = integrate(f, p);
 * \endcode
 *
 * ### Computing the second centered moment (covariance) ###
 * \f$\begin{align} \mathbb{Cov}[f(x)]
 *    & = \mathbb{E}[(f(x)-\mathbb{E}[f(x)])^2] \\
 *    & = \displaystyle\int
 *        \underbrace{\left(f(x)-\mu_f\right)\left(f(x)-\mu_f\right)^T}_{g(x):=}
 *        p(x) \mathrm{d}x \\
 *    & = \displaystyle\int g(x) p(x) \mathrm{d}x
 * \end{align}
 * \f$
 *
 * \code
 * // ... continuing the code from the previous example above
 *
 * typedef typename Gaussian<MyVariate>::SecondMoment SecondMoment;
 *
 * // create the quadratic form (f(x)-mu_f)(f(x)-mu_f)^T lambda we will pass
 * // to the integrator
 * auto g = [&](int x) -> SecondMoment
 * {
 *     return (some_function(x) - f_mean) *
 *            (some_function(x) - f_mean).transpose();
 * };
 * auto f_covariance = integrate(g, p);
 *
 *
 * \endcode
 */
template <typename Transform>
class SigmaPointQuadrature<Transform>
    : Descriptor
{
public:
    /**
     * \brief Creates a SigmaPointQuadrature
     *
     * \param transform     Transform instance, e.g. UnscentedTrasnform or
     *                      MonteCarloTransform
     */
    explicit SigmaPointQuadrature(const Transform& transform)
        : transform_(transform)
    { }

    /**
     * \brief Returns the number of points generated by transform
     *
     * \param dimension Dimension of the Gaussian
     */
    static constexpr int number_of_points(int dimension)
    {
        return Transform::number_of_points(dimension);
    }

    /**
     * \brief Returns the compile time number of points generated by transform
     *
     * \param dimension Dimension of the Gaussian
     */
    template <typename ... Variates>
    static constexpr int number_of_points()
    {
        return number_of_points(
                    JoinSizes<
                        SizeOf<Variates>::Value...
                    >::Size
                );
    }

    /** @{ */

    /**
     * \brief Integration function performing integrals of the form
     *        \f$
     *         \displaystyle\int f(x) p(x) \mathrm{d}x
     *        \f$.
     *
     * \f$p(x)\f$ is a Gaussian distribution \f${\cal N}(x; \mu_x, \Sigma_x)\f$.
     *
     * \tparam Integrand    \a Integrand function type of \f$f(x)\f$.
     *                      \a Integrand is either a \c lambda or a functor
     * \tparam Gaussian     Gaussian distribuion type of \f$p(x)\f$
     *
     * \return integration result which has the type of the specified Integrand.
     *
     * \note   This integrator is quite generic. However, it can be quite
     *         inefficient since it doesn't make any assumptions on the
     *         integration result type. It is recommanded to be used in
     *         educational and prototyping purposes only.
     *         Use propergate_gaussian() or integrate_moments() for higher
     *         efficiency.
     */
    template <
        typename Integrand,
        typename Variate
    >
    auto integrate(
            Integrand&& f,
            const Gaussian<Variate>& distr)
    -> decltype(f(distr.mean()))
    {
        const int point_count = number_of_points(distr.dimension());

        auto X = PointSet<
                     Variate,
                     number_of_points<Variate>()
                >(distr.dimension(), point_count);

        transform_(distr, X);

        auto E = f(X[0]);
        E *= X.weight(0);

        for (int i = 1; i < point_count; ++i)  E += X.weight(i) * f(X[i]);

        return E;
    }

    /**
     * \brief Integration function performing integrals of the form \n
     * \f$
     * \begin{align}
     *  \int_x\int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x
     *    = \int_x\int_y f(x, y) p(y\mid x) p(x)\mathrm{d}y\mathrm{d}x
     * \end{align}
     * \f$.
     *
     * \f$p(x)\f$ and \f$p(y\mid x)\f$ are the marginal Gaussian distributions
     * \f${\cal N}(x; \mu_x, \Sigma_x)\f$ and
     * \f${\cal N}(y; \mu_{y|x}, \Sigma_{y|x})\f$, repsectively.
     *
     * \tparam Integrand        Integrand function type of \f$f(x, y)\f$
     *
     * \return integration result which has the type of the specified Integrand.
     *
     * \note   This integrator is quite generic. However, it can be quite
     *         inefficient since it doesn't make any assumptions on the
     *         integration result type. It is recommanded to be used in
     *         educational and prototyping purposes only.
     *         Use propergate_gaussian() or integrate_moments() for higher
     *         efficiency.
     */
    template <
        typename Integrand,
        typename VariateA,
        typename VariateB
    >
    auto integrate(
            Integrand&& f,
            const Gaussian<VariateA>& marginal_gaussian_a,
            const Gaussian<VariateB>& marginal_gaussian_b)
    -> decltype(f(marginal_gaussian_a.mean(), marginal_gaussian_b.mean()))
    {
        enum : signed int
        {
            NumberOfPoints = number_of_points<VariateA, VariateB>()
        };

        const int dim_a = marginal_gaussian_a.dimension();
        const int dim_b = marginal_gaussian_b.dimension();
        const int augmented_dim = dim_a + dim_b;
        const int point_count = number_of_points(augmented_dim);

        auto X_a = PointSet<VariateA, NumberOfPoints>(dim_a, point_count);
        auto X_b = PointSet<VariateB, NumberOfPoints>(dim_b, point_count);

        transform_(marginal_gaussian_a, augmented_dim, 0, X_a);
        transform_(marginal_gaussian_b, augmented_dim, dim_a, X_b);

        auto E = f(X_a[0], X_b[0]);
        E *= X_a.weight(0);

        for (int i = 1; i < point_count; ++i)
        {
            E += X_a.weight(i) * f(X_a[i], X_b[i]);
        }

        return E;
    }

    /** @} */

    /** @{ */

    /**
     * \brief Integration function performing integrals of the form
     *        \f$
     *         \displaystyle\int f(x) p(x) \mathrm{d}x
     *        \f$.
     *
     * \f$p(x)\f$ is a Gaussian distribution \f${\cal N}(x; \mu_x, \Sigma_x)\f$.
     *
     * \tparam [int] Integrand
     *                  \a Integrand function type of \f$f(x)\f$.
     *                  \a Integrand is either a \c lambda or a functor
     * \tparam [int] Gaussian
     *                  Gaussian distribuion type of \f$p(x)\f$
     * \tparam [out] IntegrationPointSet
     *                  Integration result which is represented as a set of
     *                  points of type PointSet. The first two moments of
     *                  the point set can be used to represent a fitted
     *                  Gaussian of the integral result.
     */
    template <
        typename Integrand,
        typename Variate,
        typename IntegrandVariate
    >
    void propergate_gaussian(
            Integrand&& f,
            const Gaussian<Variate>& distr,
            PointSet<IntegrandVariate, number_of_points<Variate>()>& Z) const
    {
        PointSet<Variate, number_of_points<Variate>()> Y;
        propergate_gaussian(f, distr, Y, Z);
    }

    /**
     * \brief Integration function performing integrals of the form
     *        \f$
     *         \displaystyle\int f(x) p(x) \mathrm{d}x
     *        \f$.
     *
     * \f$p(x)\f$ is a Gaussian distribution \f${\cal N}(x; \mu_x, \Sigma_x)\f$.
     *
     * The \a GaussianPointSet \a X stores the selected quarature points of the
     * input Gaussian used for the integration. This set is particularly helpful
     * when computing the cross-covariance between the input random variable and
     * the Integrand variate, i.e/ \f$\mathbb{Cov}[X,f(X)]\f$.
     *
     * Sampe code of computing the cross-covariance
     * \code
     * auto X_c = X.centered_points();
     * auto Z_c = Z.centered_points()
     * auto W = X.covariance_weight_vector();
     * auto cov_xy = (X_c * W.asDiagonal() * Z_c.transpose()).eval();
     * \endcode
     *
     * \tparam [int] Integrand
     *                  \a Integrand function type of \f$f(x)\f$.
     *                  \a Integrand is either a \c lambda or a functor
     * \tparam [int] Gaussian
     *                  Distribuion type of \f$p(x)\f$
     * \tparam [out] GaussianPointSet
     *                  Stores the selected quarature points of the input
     *                  Gaussian used for the integration.
     * \tparam [out] IntegrationPointSet
     *                  Integration result which is represented as a set of
     *                  points of type PointSet. The first two moments of
     *                  the point set can be used to represent a fitted
     *                  Gaussian of the integral result.
     */
    template <
        typename Integrand,
        typename Variate,
        typename IntegrandVariate
    >
    void propergate_gaussian(
            Integrand&& f,
            const Gaussian<Variate>& distr,
            PointSet<Variate, number_of_points<Variate>()>& X,
            PointSet<IntegrandVariate, number_of_points<Variate>()>& Z) const
    {
        const int point_count = number_of_points(distr.dimension());

        X.resize(distr.dimension(), point_count);

        transform_(distr, X);

        auto p0 = f(X[0]);
        Z.resize(p0.size(), point_count);
        Z.point(0, p0, X.weights(0).w_mean, X.weights(0).w_cov);

        for (int i = 1; i < point_count; ++i)
        {
            Z.point(i, f(X[i]), X.weights(i).w_mean, X.weights(i).w_cov);
        }
    }

    /**
     * \brief Integration function performing integrals of the form \n
     * \f$
     * \begin{align}
     *  \int_x\int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x
     *    = \int_x\int_y f(x, y) p(y\mid x) p(x)\mathrm{d}y\mathrm{d}x
     * \end{align}
     * \f$.
     *
     * \f$p(x)\f$ and \f$p(y\mid x)\f$ are the marginal Gaussian distributions
     * \f${\cal N}(x; \mu_x, \Sigma_x)\f$ and
     * \f${\cal N}(y; \mu_{y|x}, \Sigma_{y|x})\f$, repsectively.
     *
     * The \a GaussianPointSet \a X stores the selected quarature points of the
     * input Gaussian used for the integration. This set is particularly helpful
     * when computing the cross-covariance between the input random variable and
     * the Integrand variate, i.e/ \f$\mathbb{Cov}[X,f(X)]\f$.
     *
     * Sampe code of computing the cross-covariance
     * \code
     * auto X_c = X.centered_points();
     * auto Z_c = Z.centered_points()
     * auto W = X.covariance_weight_vector();
     * auto cov_xy = (X_c * W.asDiagonal() * Z_c.transpose()).eval();
     * \endcode
     *
     * \tparam [int] Integrand
     *                  \a Integrand function type of \f$f(x)\f$.
     *                  \a Integrand is either a \c lambda or a functor
     * \tparam [int] Gaussian
     *                  Distribuion type of \f$p(x)\f$
     * \tparam [out] GaussianPointSet
     *                  Stores the selected quarature points of the input
     *                  Gaussian used for the integration.
     * \tparam [out] IntegrationPointSet
     *                  Integration result which is represented as a set of
     *                  points of type PointSet. The first two moments of
     *                  the point set can be used to represent a fitted
     *                  Gaussian of the integral result.
     */
    template <
        typename Integrand,
        typename VarA,
        typename VarB,
        typename IntegrandVariate
    >
    void propergate_gaussian(
            Integrand&& f,
            const Gaussian<VarA>& marginal_gaussian_a,
            const Gaussian<VarB>& marginal_gaussian_b,
            PointSet<IntegrandVariate, number_of_points<VarA, VarB>()>& Z) const
    {
        PointSet<VarA, number_of_points<VarA, VarB>()> X;
        PointSet<VarB, number_of_points<VarA, VarB>()> Y;
        propergate_gaussian(
            f, marginal_gaussian_a, marginal_gaussian_b, X, Y, Z);
    }

    /**
     * \brief Integration function performing integrals of the form \n
     * \f$
     * \begin{align}
     *  \int_x\int_y f(x, y) p(x, y) \mathrm{d}y\mathrm{d}x
     *    = \int_x\int_y f(x, y) p(y\mid x) p(x)\mathrm{d}y\mathrm{d}x
     * \end{align}
     * \f$.
     *
     * \f$p(x)\f$ and \f$p(y\mid x)\f$ are the marginal Gaussian distributions
     * \f${\cal N}(x; \mu_x, \Sigma_x)\f$ and
     * \f${\cal N}(y; \mu_{y|x}, \Sigma_{y|x})\f$, repsectively.
     *
     * The \a GaussianPointSet \a X stores the selected quarature points of the
     * input Gaussian used for the integration. This set is particularly helpful
     * when computing the cross-covariance between the input random variable and
     * the Integrand variate, i.e/ \f$\mathbb{Cov}[X,f(X)]\f$.
     *
     * Sampe code of computing the cross-covariance
     * \code
     * auto X_c = X.centered_points();
     * auto Z_c = Z.centered_points()
     * auto W = X.covariance_weight_vector();
     * auto cov_xy = (X_c * W.asDiagonal() * Z_c.transpose()).eval();
     * \endcode
     *
     * \tparam [int] Integrand
     *                  \a Integrand function type of \f$f(x)\f$.
     *                  \a Integrand is either a \c lambda or a functor
     * \tparam [int] Gaussian
     *                  Distribuion type of \f$p(x)\f$
     * \tparam [out] GaussianPointSet
     *                  Stores the selected quarature points of the input
     *                  Gaussian used for the integration.
     * \tparam [out] IntegrationPointSet
     *                  Integration result which is represented as a set of
     *                  points of type PointSet. The first two moments of
     *                  the point set can be used to represent a fitted
     *                  Gaussian of the integral result.
     */
    template <
        typename Integrand,
        typename VarA,
        typename VarB,
        typename IntegrandVariate
    >
    void propergate_gaussian(
            Integrand f,
            const Gaussian<VarA>& marginal_gaussian_a,
            const Gaussian<VarB>& marginal_gaussian_b,
            PointSet<VarA, number_of_points<VarA, VarB>()>& X,
            PointSet<VarB, number_of_points<VarA, VarB>()>& Y,
            PointSet<IntegrandVariate, number_of_points<VarA, VarB>()>& Z) const
    {
        const int dim_a = marginal_gaussian_a.dimension();
        const int dim_b = marginal_gaussian_b.dimension();

        const int augmented_dim = dim_a + dim_b;
        const int point_count = Transform::number_of_points(augmented_dim);

        X.resize(dim_a, point_count);
        Y.resize(dim_b, point_count);

        transform_(marginal_gaussian_a, augmented_dim, 0, X);
        transform_(marginal_gaussian_b, augmented_dim, dim_a, Y);

        auto p0 = f(X[0], Y[0]);
        Z.resize(p0.size(), point_count);
        Z.point(0, p0, X.weights(0).w_mean, X.weights(0).w_cov);

        for (int i = 1; i < point_count; ++i)
        {
            Z.point(i, f(X[i], Y[i]), X.weights(i).w_mean, X.weights(i).w_cov);
        }
    }

    /**
     *
     */
    template <
        typename Integrand,
        typename Variate,
        typename IntegrandVariate
    >
    void integrate_moments(
            Integrand f,
            const Gaussian<Variate>& distr,
            typename FirstMomentOf<IntegrandVariate>::Type& mean,
            typename SecondMomentOf<IntegrandVariate>::Type& covariance) const
    {
        auto Z = PointSet<IntegrandVariate, number_of_points<Variate>()>();

        propergate_gaussian(f, distr, Z);

        mean = Z.center();
        auto&& Z_c = Z.points();
        auto&& W = Z.covariance_weights_vector();
        covariance = Z_c * W.asDiagonal() * Z_c.transpose();
    }

    /**
     *
     */
    template <
        typename Integrand,
        typename VarA,
        typename VarB,
        typename IntegrandVariate
    >
    void integrate_moments(
            Integrand f,
            const Gaussian<VarA>& marginal_gaussian_a,
            const Gaussian<VarB>& marginal_gaussian_b,
            Gaussian<IntegrandVariate>& moments_gaussian) const
    {
        enum : signed int { NumberOfPoints = number_of_points<VarA, VarA>() };

        auto Z = PointSet<IntegrandVariate, NumberOfPoints>();

        propergate_gaussian(
            f,
            marginal_gaussian_a,
            marginal_gaussian_b,
            PointSet<VarA, NumberOfPoints>(),
            PointSet<VarA, NumberOfPoints>(),
            Z);

        moments_gaussian.mean(Z.center());
        auto&& Z_c = Z.points();
        auto&& W = Z.covariance_weights_vector();
        moments_gaussian.covariance(Z_c * W.asDiagonal() * Z_c.transpose());
    }

    /** @} */

    /** @{ */

    /**
     * \brief Returns a reference to the trandform used internally to generate
     *        the points or samples from the gaussian distributions
     */
    Transform& transform()
    {
        return transform_;
    }

    /**
     * \brief Returns a const reference to the trandform used internally to
     *        generate the points or samples from the gaussian distributions
     */
    const Transform& transform() const
    {
        return transform_;
    }

    virtual std::string name() const
    {
        return "SigmaPointQuadrature<"
                    + list_arguments(transform().name())
                + ">";
    }

    virtual std::string description() const
    {
        return "Sigma Point based numerical quadrature using :"
                + indent(transform().description());
    }

    /** @} */

protected:
    Transform transform_;
};

}

#endif
