/*
 * This is part of the FL library, a C++ Bayesian filtering library
 * (https://github.com/filtering-library)
 *
 * Copyright (c) 2014 Jan Issac (jan.issac@gmail.com)
 * Copyright (c) 2014 Manuel Wuthrich (manuel.wuthrich@gmail.com)
 *
 * This Source Code Form is subject to the terms of the MIT License (MIT).
 * A copy of the license can be found in the LICENSE file distributed with this
 * source code.
 */

/**
 * \file sigma_point_quadrature.hpp
 * \date July 2015
 * \author Jan Issac (jan.issac@gmail.com)
 */

#ifndef FL__FILTER__GAUSSIAN__SIGMA_POINT_QUADRATURE_HPP
#define FL__FILTER__GAUSSIAN__SIGMA_POINT_QUADRATURE_HPP

#include <fl/util/meta.hpp>
#include <fl/util/traits.hpp>
#include <fl/util/descriptor.hpp>
#include <fl/distribution/gaussian.hpp>
#include <fl/filter/gaussian/transform/point_set.hpp>

namespace fl
{

template <typename ... > class SigmaPointQuadrature;

template <typename Transform>
class SigmaPointQuadrature<Transform>
    : Descriptor
{
public:
    explicit SigmaPointQuadrature(const Transform& transform)
        : transform_(transform)
    { }

    /**
     * \return Number of points generated by this transform
     *
     * \param dimension Dimension of the Gaussian
     */
    static constexpr int number_of_points(int dimension)
    {
        return Transform::number_of_points(dimension);
    }

    template <typename Integrand, typename ModelGaussian, typename PriorGaussian>
    auto integrate(
            Integrand f,
            const ModelGaussian& model_distr,
            const PriorGaussian& prior_distr)
    -> decltype(f(model_distr.mean(), prior_distr.mean()))
    {
        typedef typename ModelGaussian::Variate VariateA;
        typedef typename PriorGaussian::Variate VariateB;

        enum : signed int
        {
            NumberOfPoints = Transform::number_of_points(
                                 JoinSizes<
                                     SizeOf<VariateA>::Value,
                                     SizeOf<VariateB>::Value
                                 >::Size)
        };

        typedef PointSet<VariateA, NumberOfPoints> PointSetA;
        typedef PointSet<VariateB, NumberOfPoints> PointSetB;

        int augmented_dim = model_distr.dimension() + prior_distr.dimension();
        int point_count = Transform::number_of_points(augmented_dim);

        PointSetA X_a(model_distr.dimension(), point_count);
        PointSetB X_b(prior_distr.dimension(), point_count);

        transform_(model_distr, augmented_dim, 0, X_a);
        transform_(prior_distr, augmented_dim, model_distr.dimension(), X_b);

        decltype(f(model_distr.mean(), prior_distr.mean())) E = f(X_a[0], X_b[0]);
        E *= X_a.weight(0);
        for (int i = 1; i < point_count; ++i)
        {
            E += X_a.weight(i) * f(X_a[i], X_b[i]);
        }

        return E;
    }

    template <
        typename Integrand,
        typename ModelGaussian,
        typename PriorGaussian,
        typename ModelSigmaPointsSet,
        typename PriorSigmaPointsSet,
        typename PosteriorSigmaPointsSet
    >
    void integrate_to_points(
            Integrand f,
            const ModelGaussian& model_distr,
            const PriorGaussian& prior_distr,
            ModelSigmaPointsSet& X,
            PriorSigmaPointsSet& Y,
            PosteriorSigmaPointsSet& Z) const
    {
        int augmented_dim = model_distr.dimension() + prior_distr.dimension();
        int point_count = Transform::number_of_points(augmented_dim);

        X.resize(model_distr.dimension(), point_count);
        Y.resize(prior_distr.dimension(), point_count);

        transform_(model_distr, augmented_dim, 0, X);
        transform_(prior_distr, augmented_dim, model_distr.dimension(), Y);

        auto p0 = f(X[0], Y[0]);
        Z.resize(p0.size(), point_count);
        Z.point(0, p0, X.weights(0).w_mean, X.weights(0).w_cov);

        for (int i = 1; i < point_count; ++i)
        {
            Z.point(i, f(X[i], Y[i]), X.weights(i).w_mean, X.weights(i).w_cov);
        }
    }

    template <
        typename Integrand,
        typename ModelGaussian,
        typename PriorGaussian,
        typename PosteriorSigmaPointsSet
    >
    void integrate_to_points(
            Integrand f,
            const ModelGaussian& model_distr,
            const PriorGaussian& prior_distr,
            PosteriorSigmaPointsSet& Z) const
    {
        typedef typename ModelGaussian::Variate ModelVariate;
        typedef typename PriorGaussian::Variate PriorVariate;

        enum : signed int
        {
            NumberOfPoints = number_of_points(
                                 JoinSizes<
                                     SizeOf<ModelVariate>::Value,
                                     SizeOf<PriorVariate>::Value
                                 >::Size)
        };

        typedef PointSet<ModelVariate, NumberOfPoints> ModelSigmaPointsSet;
        typedef PointSet<PriorVariate, NumberOfPoints> PriorSigmaPointsSet;

        int augmented_dim = model_distr.dimension() + prior_distr.dimension();
        int point_count = Transform::number_of_points(augmented_dim);

        auto X = ModelSigmaPointsSet(model_distr.dimension(), point_count);
        auto Y = PriorSigmaPointsSet(prior_distr.dimension(), point_count);

        integrate_to_points(f, model_distr, prior_distr, X, Y, Z);
    }

    template <
        typename Integrand,
        typename PriorGaussian,
        typename PriorSigmaPointsSet,
        typename PosteriorSigmaPointsSet
    >
    void integrate_to_points(
            Integrand f,
            const PriorGaussian& prior_distr,
            PriorSigmaPointsSet& Y,
            PosteriorSigmaPointsSet& Z) const
    {
        int point_count = Transform::number_of_points(prior_distr.dimension());

        Y.resize(prior_distr.dimension(), point_count);

        transform_(prior_distr, Y);

        auto p0 = f(Y[0]);
        Z.resize(p0.size(), point_count);
        Z.point(0, p0, Y.weights(0).w_mean, Y.weights(0).w_cov);

        for (int i = 1; i < point_count; ++i)
        {
            Z.point(i, f(Y[i]), Y.weights(i).w_mean, Y.weights(i).w_cov);
        }
    }

    Transform& transform()
    {
        return transform_;
    }

    const Transform& transform() const
    {
        return transform_;
    }

    virtual std::string name() const
    {
        return "SigmaPointQuadrature<"
                    + list_arguments(transform().name())
                + ">";
    }

    virtual std::string description() const
    {
        return "Sigma Point based numerical quadrature using :"
                + indent(transform().description());
    }

protected:
    Transform transform_;
};

}

#endif
